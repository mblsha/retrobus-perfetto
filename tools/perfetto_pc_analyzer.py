#!/usr/bin/env python3
"""
Perfetto PC Analyzer - Extract and analyze program counter addresses from Perfetto traces

This tool is designed to work with Perfetto traces generated by retrobus-perfetto
or similar CPU emulator tracing systems. It extracts PC (program counter) values
and provides performance analysis.

Usage:
    ./perfetto_pc_analyzer.py <trace_file> [--binja-path ./mcp/binja-cli.py]
"""

import struct
import argparse
import subprocess
from collections import Counter
from pathlib import Path


class PerfettoPCAnalyzer:
    """Analyzer for program counter traces in Perfetto format"""
    
    def __init__(self, trace_file, binja_cli_path=None):
        self.trace_file = Path(trace_file)
        self.binja_cli_path = Path(binja_cli_path) if binja_cli_path else None
        self.pc_counter = Counter()
        self.raw_addresses = []
        
    def extract_pc_addresses(self):
        """Extract PC addresses from the binary trace"""
        with open(self.trace_file, 'rb') as f:
            data = f.read()
        
        print(f"Analyzing {len(data):,} bytes from {self.trace_file.name}...")
        
        # Pattern for PC markers in retrobus-perfetto traces
        # This pattern may need adjustment for different trace formats
        pattern = b'\x52\x02\x70\x63'  # R.pc in hex
        
        pos = 0
        count = 0
        
        while True:
            pos = data.find(pattern, pos)
            if pos == -1:
                break
            
            # Extract address bytes based on the pattern structure
            # Pattern: 38 XX XX 3c 52 02 70 63
            if pos >= 4 and data[pos-4] == 0x38 and data[pos-1] == 0x3c:
                pc_bytes = data[pos-3:pos-1]
                if len(pc_bytes) == 2:
                    raw_value = struct.unpack('<H', pc_bytes)[0]
                    self.raw_addresses.append(raw_value)
                    
                    # Store both raw and computed addresses
                    self.pc_counter[raw_value] += 1
                    count += 1
            
            pos += 1
            
            if count % 100000 == 0 and count > 0:
                print(f"  Processed {count:,} PC values...")
        
        print(f"Total PC occurrences found: {count:,}")
        return count
    
    def map_addresses_to_regions(self, base_addresses=None):
        """Map raw addresses to memory regions"""
        if base_addresses is None:
            # Default mapping for common architectures
            base_addresses = [
                (0xe0000, "ROM Bank 5/Entry"),
                (0xc0000, "ROM Bank 4"),
                (0xa0000, "ROM Bank 3"),
                (0x80000, "ROM Bank 2"),
                (0x40000, "ROM Bank 1"),
                (0x00000, "ROM Bank 0"),
            ]
        
        mapped_counter = Counter()
        
        for raw_addr, count in self.pc_counter.items():
            # Try different interpretations
            if raw_addr > 0x80000:  # Already looks like a full address
                mapped_counter[raw_addr] += count
            else:  # Might be an offset
                for base, _ in base_addresses:
                    if raw_addr < 0x20000:  # Reasonable offset size
                        full_addr = base + raw_addr
                        if full_addr < 0x100000:  # Within address space
                            mapped_counter[full_addr] += count
                            break
        
        return mapped_counter
    
    def analyze_hotspots(self, mapped_addresses, top_n=20):
        """Analyze performance hotspots"""
        total = sum(mapped_addresses.values())
        
        print("\nPerformance Analysis")
        print("=" * 60)
        print(f"Total instructions executed: {total:,}")
        print(f"Unique addresses: {len(mapped_addresses):,}")
        
        print(f"\nTop {top_n} Hottest Addresses:")
        print("-" * 60)
        print(f"{'Address':>10} {'Count':>12} {'Percentage':>10} {'Cumulative':>10}")
        print("-" * 60)
        
        cumulative = 0
        for addr, count in mapped_addresses.most_common(top_n):
            percentage = (count / total) * 100
            cumulative += percentage
            print(f"0x{addr:08x} {count:12,} {percentage:9.1f}% {cumulative:9.1f}%")
        
        return mapped_addresses.most_common(top_n)
    
    def correlate_with_binja(self, addresses):
        """Correlate addresses with Binary Ninja if available"""
        if not self.binja_cli_path or not self.binja_cli_path.exists():
            print("\nBinary Ninja correlation skipped (no binja-cli path provided)")
            return {}
        
        print("\nBinary Ninja Function Correlation")
        print("=" * 60)
        
        results = {}
        
        for addr, count in addresses[:10]:  # Top 10 only
            try:
                # Get function info
                cmd = f"""
func = bv.get_function_at(0x{addr:x})
if func:
    print(f'FUNC:{{func.name}}')
else:
    containing = bv.get_functions_containing(0x{addr:x})
    if containing:
        f = containing[0]
        print(f'CONTAINS:{{f.name}}:0x{{addr - f.start:x}}')
    else:
        print('NONE')
"""
                result = subprocess.run(
                    [str(self.binja_cli_path), 'python', cmd],
                    capture_output=True, text=True, check=True
                )
                
                output = result.stdout.strip()
                if output.startswith('FUNC:'):
                    func_name = output[5:]
                    results[addr] = (func_name, 'start', count)
                    print(f"0x{addr:08x}: {func_name} (function start)")
                elif output.startswith('CONTAINS:'):
                    parts = output[9:].split(':')
                    func_name = parts[0]
                    offset = int(parts[1], 16)
                    results[addr] = (func_name, f'+0x{offset:x}', count)
                    print(f"0x{addr:08x}: {func_name} + 0x{offset:x}")
                
                # Get disassembly
                cmd = f"print(bv.get_disassembly(0x{addr:x}))"
                result = subprocess.run(
                    [str(self.binja_cli_path), 'python', cmd],
                    capture_output=True, text=True
                )
                if result.returncode == 0:
                    disasm = result.stdout.strip()
                    print(f"            : {disasm}")
                    
            except Exception as e:
                print(f"0x{addr:08x}: Error - {e}")
        
        return results
    
    def generate_report(self, output_file=None):
        """Generate analysis report"""
        if not output_file:
            output_file = self.trace_file.with_suffix('.analysis.txt')
        
        mapped = self.map_addresses_to_regions()
        self.analyze_hotspots(mapped)
        
        with open(output_file, 'w') as f:
            f.write("Perfetto PC Analysis Report\n")
            f.write(f"Trace file: {self.trace_file}\n")
            f.write(f"{'=' * 60}\n\n")
            
            f.write("Summary:\n")
            f.write(f"  Total PC values: {sum(self.pc_counter.values()):,}\n")
            f.write(f"  Unique addresses: {len(mapped):,}\n\n")
            
            f.write("Top 100 Addresses by Execution Count:\n")
            f.write(f"{'-' * 60}\n")
            
            for addr, count in mapped.most_common(100):
                percentage = (count / sum(mapped.values())) * 100
                f.write(f"0x{addr:08x}: {count:10,} ({percentage:5.1f}%)\n")
        
        print(f"\nReport saved to: {output_file}")
        return output_file


def main():
    parser = argparse.ArgumentParser(
        description="Extract and analyze PC addresses from Perfetto traces"
    )
    parser.add_argument("trace_file", help="Path to Perfetto trace file")
    parser.add_argument("--binja-path", help="Path to binja-cli.py for correlation")
    parser.add_argument("--top", type=int, default=20, help="Number of top addresses to show")
    parser.add_argument("--output", help="Output report file (default: <trace>.analysis.txt)")
    
    args = parser.parse_args()
    
    analyzer = PerfettoPCAnalyzer(args.trace_file, args.binja_path)
    
    # Extract addresses
    count = analyzer.extract_pc_addresses()
    if count == 0:
        print("No PC addresses found in trace")
        return
    
    # Map and analyze
    mapped = analyzer.map_addresses_to_regions()
    hotspots = analyzer.analyze_hotspots(mapped, args.top)
    
    # Binary Ninja correlation if available
    if args.binja_path:
        analyzer.correlate_with_binja(hotspots)
    
    # Generate report
    analyzer.generate_report(args.output)


if __name__ == '__main__':
    main()