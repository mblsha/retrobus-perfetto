# Perfetto Trace Analysis Tools

This directory contains reusable Python scripts for analyzing Perfetto traces, particularly those generated by CPU emulators using retrobus-perfetto or similar libraries.

## Tools

### 1. perfetto_pc_analyzer.py

Specialized tool for extracting and analyzing Program Counter (PC) addresses from CPU emulator traces.

**Features:**
- Extracts PC addresses from Perfetto traces
- Maps addresses to memory regions
- Identifies performance hotspots
- Correlates with Binary Ninja for function analysis
- Generates detailed performance reports

**Usage:**
```bash
# Basic analysis
./perfetto_pc_analyzer.py trace.perfetto-trace

# With Binary Ninja correlation
./perfetto_pc_analyzer.py trace.perfetto-trace --binja-path ./mcp/binja-cli.py

# Custom output and top addresses
./perfetto_pc_analyzer.py trace.perfetto-trace --top 50 --output analysis.txt
```

**Example Output:**
```
Performance Analysis
============================================================
Total instructions executed: 2,281,281
Unique addresses: 1,166

Top 20 Hottest Addresses:
------------------------------------------------------------
   Address        Count Percentage Cumulative
------------------------------------------------------------
0x000eaedf    1,867,215      81.9%      81.9%
0x000ec0e0        7,204       0.3%      82.2%
0x000ebad6        7,174       0.3%      82.5%
```

### 2. perfetto_trace_parser.py

Generic Perfetto trace parser for exploring and extracting data from traces.

**Features:**
- Extract strings from binary traces
- Find patterns with context
- Extract numbers following specific patterns
- Analyze protobuf structure
- Hexdump specific regions

**Usage:**
```bash
# Dump all strings in trace
./perfetto_trace_parser.py trace.perfetto-trace --dump-strings

# Find pattern occurrences
./perfetto_trace_parser.py trace.perfetto-trace --find-pattern "instruction"

# Extract 2-byte numbers after "pc" pattern
./perfetto_trace_parser.py trace.perfetto-trace --extract-numbers "pc" --num-bytes 2

# Analyze protobuf structure
./perfetto_trace_parser.py trace.perfetto-trace --analyze-proto

# Hexdump from specific offset
./perfetto_trace_parser.py trace.perfetto-trace --hexdump 0x1000
```

### 3. perfetto_trace_compare.py

Side-by-side comparison tool for two Perfetto traces that should represent the same execution.

**Features:**
- Compares execution events from the "Execution" timeline
- Ignores thread IDs (which may differ between runs)
- Compares debug annotations as string values
- Shows exactly where traces diverge
- Provides detailed diff output for mismatches

**Usage:**
```bash
# Basic comparison
./perfetto_trace_compare.py trace1.perfetto trace2.perfetto

# With verbose progress output
./perfetto_trace_compare.py trace1.perfetto trace2.perfetto --verbose
```

**Use Cases:**
- Verify emulator determinism
- Compare different emulator implementations
- Debug non-deterministic behavior
- Regression testing

### 4. perfetto_function_trace_summary.py

Summarize function call slices (typically on the `Functions` track) into a compact YAML call graph.

**Features:**
- Aggregates call counts and deduplicates debug-annotation payloads
- Resolves function names via JSON maps (supports `bnida.json`-style `names` dictionaries)
- Optional track filtering and integer formatting

**Usage:**
```bash
# Summarize the Functions track (default)
./perfetto_function_trace_summary.py trace.perfetto-trace

# Explicit track filtering and key suppression
./perfetto_function_trace_summary.py trace.perfetto-trace --track Functions --ignore-key op_index

# Resolve names via a JSON map (e.g., bnida.json)
./perfetto_function_trace_summary.py trace.perfetto-trace --name-map path/to/bnida.json
```

## Customization

### Adapting for Different CPU Architectures

The PC analyzer can be customized for different architectures by modifying the address extraction pattern and memory region mapping:

```python
# In perfetto_pc_analyzer.py, modify the pattern
pattern = b'\x52\x02\x70\x63'  # Default pattern for "pc"

# Customize memory regions
base_addresses = [
    (0xe0000, "ROM Bank 5"),
    (0xc0000, "ROM Bank 4"),
    # Add your architecture's memory map
]
```

### Adding New Patterns

For the generic parser, you can add new extraction patterns:

```python
# Extract different data types
parser = PerfettoTraceParser("trace.perfetto-trace")
parser.load()

# Extract custom patterns
contexts = parser.find_pattern_context(b'\x12\x34\x56')
numbers = parser.extract_numbers("reg", num_bytes=4)
```

## Integration with Other Tools

### Binary Ninja Integration

The PC analyzer can correlate addresses with Binary Ninja disassembly:

1. Ensure you have `binja-cli.py` available
2. Use the `--binja-path` option
3. The tool will automatically query function names and disassembly

### Generating Reports

Both tools can generate reports suitable for further analysis:

```bash
# Generate CSV-compatible output
./perfetto_pc_analyzer.py trace.perfetto-trace | grep "0x" | awk '{print $1","$2}' > hotspots.csv
```

## Requirements

- Python 3.6+
- No external dependencies (uses only standard library)
- Optional: Binary Ninja with MCP CLI for enhanced analysis

## Tips for Effective Analysis

1. **Start with the generic parser** to understand your trace format
2. **Look for patterns** in the hexdump to identify how data is encoded
3. **Use string extraction** to find markers and identifiers
4. **Customize the PC analyzer** pattern matching for your specific trace format
5. **Cross-reference with disassembly** to understand what hot code is doing

## Example Workflow

```bash
# 1. Explore trace structure
./perfetto_trace_parser.py my_trace.perfetto-trace --dump-strings | head -20
./perfetto_trace_parser.py my_trace.perfetto-trace --find-pattern "pc"

# 2. Extract and analyze PC addresses
./perfetto_pc_analyzer.py my_trace.perfetto-trace --binja-path ./binja-cli.py

# 3. Deep dive into hotspots
# Look at the generated analysis.txt file
# Use Binary Ninja to examine the hot functions
```

## Limitations

- These tools parse Perfetto traces at a binary level without the full protobuf schema
- Pattern matching may need adjustment for different trace formats
- Large traces (>1GB) may require memory optimization

## Contributing

To add support for new trace formats:
1. Identify the binary pattern for your data
2. Add extraction logic to the appropriate tool
3. Document the pattern format
4. Submit examples of successful parsing
